# Leetcode

# 环境

https://github.com/zsjun/leetcode.git <br>
下载下来之后，可以直接在 src/code 里边写算法，在 src/test 里边写测试用例，然后运行 yarn run test 即可

# 什么是算法？

算法看起来高大上，其实仔细想想，你每天都在用算法，比如去上班，你决定如何去，是坐地铁还是开车，还是做公交，这其实就是一个决定算法，你根据这个算法，来决定自己如何出行。<br>
这么一想，是不是感觉算法其实没有那么高大上，也就很容易去除对算法的畏惧心理。

# 字符串

##1 给定一个字符串  s，计算具有相同数量 0 和 1 的非空(连续)子字符串的数量，并且这些子字符串中的所有 0 和所有 1 都是组合在一起的。

重复出现的子串要计算它们出现的次数。
例子 1：

```js
输入: "00110011"
输出: 6
解释: 有6个子串具有相同数量的连续1和0：“0011”，“01”，“1100”，“10”，“0011” 和 “01”。

请注意，一些重复出现的子串要计算它们出现的次数。

另外，“00110011”不是有效的子串，因为所有的0（和1）没有组合在一起。

```

# 数组

##1 卡牌分组

给定一副牌，每张牌上都写着一个整数。

此时，你需要选定一个数字 X，使我们可以将整副牌按下述规则分成 1 组或更多组：

每组都有  X  张牌。
组内所有的牌上都写着相同的整数。
仅当你可选的 X >= 2 时返回  true。

例子 1

```
输入：[1,2,3,4,4,3,2,1]
输出：true
解释：可行的分组是 [1,1]，[2,2]，[3,3]，[4,4]
```

例子 2

```
输入：[1,1,1,2,2,2,3,3]
输出：false
解释：没有满足要求的分组。
```

例子 3

```
输入：[1,1]
输出：true
解释：可行的分组是 [1,1]
```

## 格雷编码

格雷编码是一个二进制数字系统，在该系统中，两个连续的数值仅有一个位数的差异。

给定一个代表编码总位数的非负整数 n，打印其格雷编码序列。格雷编码序列必须以 0 开头。

例子 1：

```js
输入: 2
输出: [0,1,3,2]
解释:
00 - 0
01 - 1
11 - 3
10 - 2

对于给定的 n，其格雷编码序列并不唯一。
例如，[0,2,3,1] 也是一个有效的格雷编码序列。

00 - 0
10 - 2
11 - 3
01 - 1

```

例子 2：

```js
输入: 0
输出: [0]
解释: 我们定义格雷编码序列必须以 0 开头。
     给定编码总位数为 n 的格雷编码序列，其长度为 2n。当 n = 0 时，长度为 20 = 1。
     因此，当 n = 0 时，其格雷编码序列为 [0]。

```

当题目中的测试用例比较少的时候，可以自己多写几个测试用例，比如这里当 n=3 的时候，基本就可以发现规律了。

## 冒泡排序

不断的上浮，直到排列完成。

## 选择排序

## 最大间距

给定一个无序的数组，找出数组在排序之后，相邻元素之间最大的差值。

如果数组元素个数小于 2，则返回 0。
例子 1：

```js
输入: [3,6,9,1]
输出: 3
解释: 排序后的数组是 [1,3,6,9], 其中相邻元素 (3,6) 和 (6,9) 之间都存在最大差值 3。
```

例子 2：

```js
输入: [10]
输出: 0
解释: 数组元素个数小于 2，因此返回 0。
```

解：
这个很简单，简单的通过冒泡排序，在排序的过程中刚好记录下两者的差值，就可以找出最大的间距了。

# 正则表达式

##1 重复子字符串
给定一个非空的字符串，判断它是否可以由它的一个子串重复多次构成。给定的字符串只含有小写英文字母，并且长度不超过 10000。

例子 1：

```js
输入: "abab"

输出: True

解释: 可由子字符串 "ab" 重复两次构成。
```

解：
只需要了解下正则匹配即可
/^(\w+)\1+\$/

## 正则表达式匹配

给你一个字符串  s  和一个字符规律  p，请你来实现一个支持 '.'  和  '\*'  的正则表达式匹配。

'.' 匹配任意单个字符
'\*' 匹配零个或多个前面的那一个元素
所谓匹配，是要涵盖   整个   字符串  s 的，而不是部分字符串。

说明:

s  可能为空，且只包含从  a-z  的小写字母。
p  可能为空，且只包含从  a-z  的小写字母，以及字符  .  和  \*。

例子 1：

```js
输入:
s = "aa"
p = "a"
输出: false
解释: "a" 无法匹配 "aa" 整个字符串。
```

解：
正则/([a-z.]\*)|([a-z]+(?=([a-z.]\*)|\$))/g

# 递归

## 复原 IP 地址

给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。

例子 1：

```js
输入: "25525511135";
输出: ["255.255.11.135", "255.255.111.35"];
```

解：
这个应该很简单，看到归类到递归，很容易想到使用递归来解决。

## 串联所有单词的子串

给定一个字符串  s  和一些长度相同的单词  words。找出 s 中恰好可以由  words 中所有单词串联形成的子串的起始位置。

注意子串要与  words 中的单词完全匹配，中间不能有其他字符，但不需要考虑  words  中单词串联的顺序。

例子 1：

```js
输入：
  s = "barfoothefoobarman",
  words = ["foo","bar"]
输出：[0,9]
解释：
从索引 0 和 9 开始的子串分别是 "barfoo" 和 "foobar" 。
输出的顺序不重要, [9,0] 也是有效答案。

```

例子 2：

```js
输入：
  s = "wordgoodgoodgoodbestword",
  words = ["word","good","best","word"]
输出：[]

```

解：
这个也很简单，还是使用递归。

# 栈

## 最大矩形

给定一个仅包含 0 和 1 的二维二进制矩阵，找出只包含 1 的最大矩形，并返回其面积。

例子 1：

```js
输入: [
  ["1", "0", "1", "0", "0"],
  ["1", "0", "1", "1", "1"],
  ["1", "1", "1", "1", "1"],
  ["1", "0", "0", "1", "0"],
];
输出: 6;
```

难点：
没有拆解出来小问题

# 队列

## 设计循环队列

设计你的循环队列实现。 循环队列是一种线性数据结构，其操作表现基于 FIFO（先进先出）原则并且队尾被连接在队首之后以形成一个循环。它也被称为“环形缓冲器”。

循环队列的一个好处是我们可以利用这个队列之前用过的空间。在一个普通队列里，一旦一个队列满了，我们就不能插入下一个元素，即使在队列前面仍有空间。但是使用循环队列，我们能使用这些空间去存储新的值。

你的实现应该支持如下操作：

1 MyCircularQueue(k): 构造器，设置队列长度为 k 。<br>
2 Front: 从队首获取元素。如果队列为空，返回 -1 。<br>
3 Rear: 获取队尾元素。如果队列为空，返回 -1 。<br>
4 enQueue(value): 向循环队列插入一个元素。如果成功插入则返回真。<br>
5 deQueue(): 从循环队列中删除一个元素。如果成功删除则返回真。<br>
6 isEmpty(): 检查循环队列是否为空。<br>
7 isFull(): 检查循环队列是否已满。<br>

例子 1：

```js
MyCircularQueue circularQueue = new MyCircularQueue(3); // 设置长度为 3

circularQueue.enQueue(1);  // 返回 true

circularQueue.enQueue(2);  // 返回 true

circularQueue.enQueue(3);  // 返回 true

circularQueue.enQueue(4);  // 返回 false，队列已满

circularQueue.Rear();  // 返回 3

circularQueue.isFull();  // 返回 true

circularQueue.deQueue();  // 返回 true

circularQueue.enQueue(4);  // 返回 true

circularQueue.Rear();  // 返回 4

```

注意：

所有的值都在 0 至 1000 的范围内；<br>
操作数将在 1 至 1000 的范围内；<br>
请不要使用内置的队列库。<br>

# 链表

## 排序链表

在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序。

例子 1：

```js
输入: 4->2->1->3
输出: 1->2->3->4
```

例子 2：

```js
输入: -1->5->3->4->0
输出: -1->0->3->4->5
```

难点：
需要知道使用哪种排序符合题目的要求，目前符合的只有堆排序

## 跳表

升维
空间换时间
利用索引，加大链表遍历的速度

# 矩阵

## 螺旋矩阵

给定一个包含 m x n 个元素的矩阵（m 行, n 列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。

例子 1：

```js
输入: [
  [1, 2, 3],
  [4, 5, 6],
  [7, 8, 9],
];
输出: [1, 2, 3, 6, 9, 8, 7, 4, 5];
```

例子 1：

```js
输入: [
  [1, 2, 3, 4],
  [5, 6, 7, 8],
  [9, 10, 11, 12],
];
输出: [1, 2, 3, 4, 8, 12, 11, 10, 9, 5, 6, 7];
```

难点
1，以大化小，分而治之，复杂的问题可以拆分成比较小的问题，然后利用递归来处理。

# 堆

1，必须是完全二叉树
2，任一节点都是子树的最大值或者最小值

## 超级丑数

编写一段程序来查找第 n 个超级丑数。

超级丑数是指其所有质因数都是长度为 k 的质数列表 primes 中的正整数。

例子 1：

```js
输入: n = 12, primes = [2,7,13,19]
输出: 32
解释: 给定长度为 4 的质数列表 primes = [2,7,13,19]，前 12 个超级丑数序列为：[1,2,4,7,8,13,14,16,19,26,28,32] 。

```

说明：
1  是任何给定  primes  的超级丑数。
  给定  primes  中的数字以升序排列。
0 < k ≤ 100, 0 < n ≤ 106, 0 < primes[i] < 1000 。
第  n  个超级丑数确保在 32 位有符整数范围内。

# 算法思想

## 贪心算法

### 给定一个数组，它的第  i 个元素是一支给定股票第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。

注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

例子 1：

```js
输入: [7,1,5,3,6,4]
输出: 7
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。
```

例子 2：

```
输入: [1,2,3,4,5]
输出: 4
解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。
     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。
```

例子 3：

```js
输入: [7,6,4,3,1]
输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。
```

# 动态规划

## K 站中转内最便宜的航班

有 n 个城市通过 m 个航班连接。每个航班都从城市 u 开始，以价格 w 抵达 v。

现在给定所有的城市和航班，以及出发城市 src 和目的地 dst，你的任务是找到从 src 到 dst 最多经过 k  站中转的最便宜的价格。 如果没有这样的路线，则输出 -1。
