<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Leetcode | 云旭泉的博客</title>
    <meta name="generator" content="VuePress 1.5.1">
    
    <meta name="description" content="专注全栈技术分享">
    <link rel="preload" href="/blog/assets/css/0.styles.39c0576a.css" as="style"><link rel="preload" href="/blog/assets/js/app.9b8d30b8.js" as="script"><link rel="preload" href="/blog/assets/js/2.0a93f5dd.js" as="script"><link rel="preload" href="/blog/assets/js/12.e0a98157.js" as="script"><link rel="prefetch" href="/blog/assets/js/10.f798a2d8.js"><link rel="prefetch" href="/blog/assets/js/11.d54a8208.js"><link rel="prefetch" href="/blog/assets/js/13.87c877fd.js"><link rel="prefetch" href="/blog/assets/js/14.d7c59895.js"><link rel="prefetch" href="/blog/assets/js/15.6277aecb.js"><link rel="prefetch" href="/blog/assets/js/16.01e8b1ad.js"><link rel="prefetch" href="/blog/assets/js/17.712b9225.js"><link rel="prefetch" href="/blog/assets/js/18.522ef26f.js"><link rel="prefetch" href="/blog/assets/js/19.5445ecf3.js"><link rel="prefetch" href="/blog/assets/js/20.47f43b7b.js"><link rel="prefetch" href="/blog/assets/js/21.9f8c275f.js"><link rel="prefetch" href="/blog/assets/js/22.a756c658.js"><link rel="prefetch" href="/blog/assets/js/23.b4bcee6c.js"><link rel="prefetch" href="/blog/assets/js/24.8ec49f71.js"><link rel="prefetch" href="/blog/assets/js/25.775adcca.js"><link rel="prefetch" href="/blog/assets/js/26.ee451341.js"><link rel="prefetch" href="/blog/assets/js/27.d3f4e021.js"><link rel="prefetch" href="/blog/assets/js/28.b9c8da82.js"><link rel="prefetch" href="/blog/assets/js/29.d8e3f233.js"><link rel="prefetch" href="/blog/assets/js/3.ffb23f29.js"><link rel="prefetch" href="/blog/assets/js/30.931a269f.js"><link rel="prefetch" href="/blog/assets/js/31.0125aec6.js"><link rel="prefetch" href="/blog/assets/js/32.bf0f1052.js"><link rel="prefetch" href="/blog/assets/js/33.1b679a21.js"><link rel="prefetch" href="/blog/assets/js/34.b5543fb7.js"><link rel="prefetch" href="/blog/assets/js/35.0bfad671.js"><link rel="prefetch" href="/blog/assets/js/36.de9fee6a.js"><link rel="prefetch" href="/blog/assets/js/37.eaaf3327.js"><link rel="prefetch" href="/blog/assets/js/38.1e0f9389.js"><link rel="prefetch" href="/blog/assets/js/39.5ec5bcd4.js"><link rel="prefetch" href="/blog/assets/js/4.a0155084.js"><link rel="prefetch" href="/blog/assets/js/40.a851c68a.js"><link rel="prefetch" href="/blog/assets/js/41.ce3ebcca.js"><link rel="prefetch" href="/blog/assets/js/42.d7a988ab.js"><link rel="prefetch" href="/blog/assets/js/43.34c1ed44.js"><link rel="prefetch" href="/blog/assets/js/44.8f6680b9.js"><link rel="prefetch" href="/blog/assets/js/45.0fbc2ae1.js"><link rel="prefetch" href="/blog/assets/js/46.fd04d742.js"><link rel="prefetch" href="/blog/assets/js/47.1ec9c3da.js"><link rel="prefetch" href="/blog/assets/js/48.081d87ac.js"><link rel="prefetch" href="/blog/assets/js/49.eb09b8f9.js"><link rel="prefetch" href="/blog/assets/js/5.e569c75c.js"><link rel="prefetch" href="/blog/assets/js/50.7d1733bd.js"><link rel="prefetch" href="/blog/assets/js/51.0c621372.js"><link rel="prefetch" href="/blog/assets/js/52.63757a91.js"><link rel="prefetch" href="/blog/assets/js/53.6d33b67a.js"><link rel="prefetch" href="/blog/assets/js/54.d6014ffc.js"><link rel="prefetch" href="/blog/assets/js/6.eb41542c.js"><link rel="prefetch" href="/blog/assets/js/7.f36d4014.js"><link rel="prefetch" href="/blog/assets/js/8.5980153c.js"><link rel="prefetch" href="/blog/assets/js/9.cadab512.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.39c0576a.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link router-link-active"><!----> <span class="site-name">云旭泉的博客</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blog/" class="nav-link">
  主页
</a></div><div class="nav-item"><a href="/blog/node/" class="nav-link">
  node
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端" class="dropdown-title"><span class="title">前端</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/web/react/" class="nav-link">
  react
</a></li><li class="dropdown-item"><!----> <a href="/blog/web/js/" class="nav-link">
  js
</a></li></ul></div></div><div class="nav-item"><a href="/blog/rearend/" class="nav-link">
  后端
</a></div><div class="nav-item"><a href="/blog/interview/" class="nav-link router-link-active">
  面试问题
</a></div><div class="nav-item"><a href="/blog/other/" class="nav-link">
  其它
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/blog/" class="nav-link">
  主页
</a></div><div class="nav-item"><a href="/blog/node/" class="nav-link">
  node
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端" class="dropdown-title"><span class="title">前端</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/web/react/" class="nav-link">
  react
</a></li><li class="dropdown-item"><!----> <a href="/blog/web/js/" class="nav-link">
  js
</a></li></ul></div></div><div class="nav-item"><a href="/blog/rearend/" class="nav-link">
  后端
</a></div><div class="nav-item"><a href="/blog/interview/" class="nav-link router-link-active">
  面试问题
</a></div><div class="nav-item"><a href="/blog/other/" class="nav-link">
  其它
</a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/blog/interview/fe-dictionary.html" class="sidebar-link">前端面试宝典</a></li><li><a href="/blog/interview/fetch.html" class="sidebar-link">Fetch error</a></li><li><a href="/blog/interview/session.html" class="sidebar-link">前端安全</a></li><li><a href="/blog/interview/leetcode.html" aria-current="page" class="active sidebar-link">Leetcode</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/interview/leetcode.html#格雷编码" class="sidebar-link">格雷编码</a></li><li class="sidebar-sub-header"><a href="/blog/interview/leetcode.html#冒泡排序" class="sidebar-link">冒泡排序</a></li><li class="sidebar-sub-header"><a href="/blog/interview/leetcode.html#选择排序" class="sidebar-link">选择排序</a></li><li class="sidebar-sub-header"><a href="/blog/interview/leetcode.html#最大间距" class="sidebar-link">最大间距</a></li><li class="sidebar-sub-header"><a href="/blog/interview/leetcode.html#正则表达式匹配" class="sidebar-link">正则表达式匹配</a></li><li class="sidebar-sub-header"><a href="/blog/interview/leetcode.html#复原-ip-地址" class="sidebar-link">复原 IP 地址</a></li><li class="sidebar-sub-header"><a href="/blog/interview/leetcode.html#串联所有单词的子串" class="sidebar-link">串联所有单词的子串</a></li><li class="sidebar-sub-header"><a href="/blog/interview/leetcode.html#最大矩形" class="sidebar-link">最大矩形</a></li><li class="sidebar-sub-header"><a href="/blog/interview/leetcode.html#设计循环队列" class="sidebar-link">设计循环队列</a></li><li class="sidebar-sub-header"><a href="/blog/interview/leetcode.html#排序链表" class="sidebar-link">排序链表</a></li><li class="sidebar-sub-header"><a href="/blog/interview/leetcode.html#跳表" class="sidebar-link">跳表</a></li><li class="sidebar-sub-header"><a href="/blog/interview/leetcode.html#螺旋矩阵" class="sidebar-link">螺旋矩阵</a></li><li class="sidebar-sub-header"><a href="/blog/interview/leetcode.html#超级丑数" class="sidebar-link">超级丑数</a></li><li class="sidebar-sub-header"><a href="/blog/interview/leetcode.html#贪心算法" class="sidebar-link">贪心算法</a></li><li class="sidebar-sub-header"><a href="/blog/interview/leetcode.html#k-站中转内最便宜的航班" class="sidebar-link">K 站中转内最便宜的航班</a></li></ul></li><li><a href="/blog/interview/设计模式.html" class="sidebar-link">设计模式</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="leetcode"><a href="#leetcode" class="header-anchor">#</a> Leetcode</h1> <h1 id="环境"><a href="#环境" class="header-anchor">#</a> 环境</h1> <p>https://github.com/zsjun/leetcode.git <br>
下载下来之后，可以直接在 src/code 里边写算法，在 src/test 里边写测试用例，然后运行 yarn run test 即可</p> <h1 id="什么是算法？"><a href="#什么是算法？" class="header-anchor">#</a> 什么是算法？</h1> <p>算法看起来高大上，其实仔细想想，你每天都在用算法，比如去上班，你决定如何去，是坐地铁还是开车，还是做公交，这其实就是一个决定算法，你根据这个算法，来决定自己如何出行。<br>
这么一想，是不是感觉算法其实没有那么高大上，也就很容易去除对算法的畏惧心理。</p> <h1 id="字符串"><a href="#字符串" class="header-anchor">#</a> 字符串</h1> <p>##1 给定一个字符串  s，计算具有相同数量 0 和 1 的非空(连续)子字符串的数量，并且这些子字符串中的所有 0 和所有 1 都是组合在一起的。</p> <p>重复出现的子串要计算它们出现的次数。
例子 1：</p> <div class="language-js extra-class"><pre class="language-js"><code>输入<span class="token operator">:</span> <span class="token string">&quot;00110011&quot;</span>
输出<span class="token operator">:</span> <span class="token number">6</span>
解释<span class="token operator">:</span> 有<span class="token number">6</span>个子串具有相同数量的连续<span class="token number">1</span>和<span class="token number">0</span>：“<span class="token number">0011</span>”，“<span class="token number">01</span>”，“<span class="token number">1100</span>”，“<span class="token number">10</span>”，“<span class="token number">0011</span>” 和 “<span class="token number">01</span>”。

请注意，一些重复出现的子串要计算它们出现的次数。

另外，“<span class="token number">00110011</span>”不是有效的子串，因为所有的<span class="token number">0</span>（和<span class="token number">1</span>）没有组合在一起。

</code></pre></div><h1 id="数组"><a href="#数组" class="header-anchor">#</a> 数组</h1> <p>##1 卡牌分组</p> <p>给定一副牌，每张牌上都写着一个整数。</p> <p>此时，你需要选定一个数字 X，使我们可以将整副牌按下述规则分成 1 组或更多组：</p> <p>每组都有  X  张牌。
组内所有的牌上都写着相同的整数。
仅当你可选的 X &gt;= 2 时返回  true。</p> <p>例子 1</p> <div class="language- extra-class"><pre class="language-text"><code>输入：[1,2,3,4,4,3,2,1]
输出：true
解释：可行的分组是 [1,1]，[2,2]，[3,3]，[4,4]
</code></pre></div><p>例子 2</p> <div class="language- extra-class"><pre class="language-text"><code>输入：[1,1,1,2,2,2,3,3]
输出：false
解释：没有满足要求的分组。
</code></pre></div><p>例子 3</p> <div class="language- extra-class"><pre class="language-text"><code>输入：[1,1]
输出：true
解释：可行的分组是 [1,1]
</code></pre></div><h2 id="格雷编码"><a href="#格雷编码" class="header-anchor">#</a> 格雷编码</h2> <p>格雷编码是一个二进制数字系统，在该系统中，两个连续的数值仅有一个位数的差异。</p> <p>给定一个代表编码总位数的非负整数 n，打印其格雷编码序列。格雷编码序列必须以 0 开头。</p> <p>例子 1：</p> <div class="language-js extra-class"><pre class="language-js"><code>输入<span class="token operator">:</span> <span class="token number">2</span>
输出<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span>
解释<span class="token operator">:</span>
<span class="token number">00</span> <span class="token operator">-</span> <span class="token number">0</span>
<span class="token number">01</span> <span class="token operator">-</span> <span class="token number">1</span>
<span class="token number">11</span> <span class="token operator">-</span> <span class="token number">3</span>
<span class="token number">10</span> <span class="token operator">-</span> <span class="token number">2</span>

对于给定的 n，其格雷编码序列并不唯一。
例如，<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span> 也是一个有效的格雷编码序列。

<span class="token number">00</span> <span class="token operator">-</span> <span class="token number">0</span>
<span class="token number">10</span> <span class="token operator">-</span> <span class="token number">2</span>
<span class="token number">11</span> <span class="token operator">-</span> <span class="token number">3</span>
<span class="token number">01</span> <span class="token operator">-</span> <span class="token number">1</span>

</code></pre></div><p>例子 2：</p> <div class="language-js extra-class"><pre class="language-js"><code>输入<span class="token operator">:</span> <span class="token number">0</span>
输出<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
解释<span class="token operator">:</span> 我们定义格雷编码序列必须以 <span class="token number">0</span> 开头。
     给定编码总位数为 n 的格雷编码序列，其长度为 <span class="token number">2n</span>。当 n <span class="token operator">=</span> <span class="token number">0</span> 时，长度为 <span class="token number">20</span> <span class="token operator">=</span> <span class="token number">1</span>。
     因此，当 n <span class="token operator">=</span> <span class="token number">0</span> 时，其格雷编码序列为 <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>。

</code></pre></div><p>当题目中的测试用例比较少的时候，可以自己多写几个测试用例，比如这里当 n=3 的时候，基本就可以发现规律了。</p> <h2 id="冒泡排序"><a href="#冒泡排序" class="header-anchor">#</a> 冒泡排序</h2> <p>不断的上浮，直到排列完成。</p> <h2 id="选择排序"><a href="#选择排序" class="header-anchor">#</a> 选择排序</h2> <h2 id="最大间距"><a href="#最大间距" class="header-anchor">#</a> 最大间距</h2> <p>给定一个无序的数组，找出数组在排序之后，相邻元素之间最大的差值。</p> <p>如果数组元素个数小于 2，则返回 0。
例子 1：</p> <div class="language-js extra-class"><pre class="language-js"><code>输入<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span>
输出<span class="token operator">:</span> <span class="token number">3</span>
解释<span class="token operator">:</span> 排序后的数组是 <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token function">其中相邻元素</span> <span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">)</span> <span class="token function">和</span> <span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">)</span> 之间都存在最大差值 <span class="token number">3</span>。
</code></pre></div><p>例子 2：</p> <div class="language-js extra-class"><pre class="language-js"><code>输入<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span>
输出<span class="token operator">:</span> <span class="token number">0</span>
解释<span class="token operator">:</span> 数组元素个数小于 <span class="token number">2</span>，因此返回 <span class="token number">0</span>。
</code></pre></div><p>解：
这个很简单，简单的通过冒泡排序，在排序的过程中刚好记录下两者的差值，就可以找出最大的间距了。</p> <h1 id="正则表达式"><a href="#正则表达式" class="header-anchor">#</a> 正则表达式</h1> <p>##1 重复子字符串
给定一个非空的字符串，判断它是否可以由它的一个子串重复多次构成。给定的字符串只含有小写英文字母，并且长度不超过 10000。</p> <p>例子 1：</p> <div class="language-js extra-class"><pre class="language-js"><code>输入<span class="token operator">:</span> <span class="token string">&quot;abab&quot;</span>

输出<span class="token operator">:</span> True

解释<span class="token operator">:</span> 可由子字符串 <span class="token string">&quot;ab&quot;</span> 重复两次构成。
</code></pre></div><p>解：
只需要了解下正则匹配即可
/^(\w+)\1+$/</p> <h2 id="正则表达式匹配"><a href="#正则表达式匹配" class="header-anchor">#</a> 正则表达式匹配</h2> <p>给你一个字符串  s  和一个字符规律  p，请你来实现一个支持 '.'  和  '*'  的正则表达式匹配。</p> <p>'.' 匹配任意单个字符
'*' 匹配零个或多个前面的那一个元素
所谓匹配，是要涵盖   整个   字符串  s 的，而不是部分字符串。</p> <p>说明:</p> <p>s  可能为空，且只包含从  a-z  的小写字母。
p  可能为空，且只包含从  a-z  的小写字母，以及字符  .  和  *。</p> <p>例子 1：</p> <div class="language-js extra-class"><pre class="language-js"><code>输入<span class="token operator">:</span>
s <span class="token operator">=</span> <span class="token string">&quot;aa&quot;</span>
p <span class="token operator">=</span> <span class="token string">&quot;a&quot;</span>
输出<span class="token operator">:</span> <span class="token boolean">false</span>
解释<span class="token operator">:</span> <span class="token string">&quot;a&quot;</span> 无法匹配 <span class="token string">&quot;aa&quot;</span> 整个字符串。
</code></pre></div><p>解：
正则/([a-z.]*)|([a-z]+(?=([a-z.]*)|$))/g</p> <h1 id="递归"><a href="#递归" class="header-anchor">#</a> 递归</h1> <h2 id="复原-ip-地址"><a href="#复原-ip-地址" class="header-anchor">#</a> 复原 IP 地址</h2> <p>给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。</p> <p>例子 1：</p> <div class="language-js extra-class"><pre class="language-js"><code>输入<span class="token operator">:</span> <span class="token string">&quot;25525511135&quot;</span><span class="token punctuation">;</span>
输出<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">&quot;255.255.11.135&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;255.255.111.35&quot;</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre></div><p>解：
这个应该很简单，看到归类到递归，很容易想到使用递归来解决。</p> <h2 id="串联所有单词的子串"><a href="#串联所有单词的子串" class="header-anchor">#</a> 串联所有单词的子串</h2> <p>给定一个字符串  s  和一些长度相同的单词  words。找出 s 中恰好可以由  words 中所有单词串联形成的子串的起始位置。</p> <p>注意子串要与  words 中的单词完全匹配，中间不能有其他字符，但不需要考虑  words  中单词串联的顺序。</p> <p>例子 1：</p> <div class="language-js extra-class"><pre class="language-js"><code>输入：
  s <span class="token operator">=</span> <span class="token string">&quot;barfoothefoobarman&quot;</span><span class="token punctuation">,</span>
  words <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">&quot;foo&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;bar&quot;</span><span class="token punctuation">]</span>
输出：<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">]</span>
解释：
从索引 <span class="token number">0</span> 和 <span class="token number">9</span> 开始的子串分别是 <span class="token string">&quot;barfoo&quot;</span> 和 <span class="token string">&quot;foobar&quot;</span> 。
输出的顺序不重要<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span> 也是有效答案。

</code></pre></div><p>例子 2：</p> <div class="language-js extra-class"><pre class="language-js"><code>输入：
  s <span class="token operator">=</span> <span class="token string">&quot;wordgoodgoodgoodbestword&quot;</span><span class="token punctuation">,</span>
  words <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">&quot;word&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;good&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;best&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;word&quot;</span><span class="token punctuation">]</span>
输出：<span class="token punctuation">[</span><span class="token punctuation">]</span>

</code></pre></div><p>解：
这个也很简单，还是使用递归。</p> <h1 id="栈"><a href="#栈" class="header-anchor">#</a> 栈</h1> <h2 id="最大矩形"><a href="#最大矩形" class="header-anchor">#</a> 最大矩形</h2> <p>给定一个仅包含 0 和 1 的二维二进制矩阵，找出只包含 1 的最大矩形，并返回其面积。</p> <p>例子 1：</p> <div class="language-js extra-class"><pre class="language-js"><code>输入<span class="token operator">:</span> <span class="token punctuation">[</span>
  <span class="token punctuation">[</span><span class="token string">&quot;1&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;0&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;1&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;0&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;0&quot;</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token punctuation">[</span><span class="token string">&quot;1&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;0&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;1&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;1&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;1&quot;</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token punctuation">[</span><span class="token string">&quot;1&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;1&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;1&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;1&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;1&quot;</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token punctuation">[</span><span class="token string">&quot;1&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;0&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;0&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;1&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;0&quot;</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token punctuation">]</span><span class="token punctuation">;</span>
输出<span class="token operator">:</span> <span class="token number">6</span><span class="token punctuation">;</span>
</code></pre></div><p>难点：
没有拆解出来小问题</p> <h1 id="队列"><a href="#队列" class="header-anchor">#</a> 队列</h1> <h2 id="设计循环队列"><a href="#设计循环队列" class="header-anchor">#</a> 设计循环队列</h2> <p>设计你的循环队列实现。 循环队列是一种线性数据结构，其操作表现基于 FIFO（先进先出）原则并且队尾被连接在队首之后以形成一个循环。它也被称为“环形缓冲器”。</p> <p>循环队列的一个好处是我们可以利用这个队列之前用过的空间。在一个普通队列里，一旦一个队列满了，我们就不能插入下一个元素，即使在队列前面仍有空间。但是使用循环队列，我们能使用这些空间去存储新的值。</p> <p>你的实现应该支持如下操作：</p> <p>1 MyCircularQueue(k): 构造器，设置队列长度为 k 。<br>
2 Front: 从队首获取元素。如果队列为空，返回 -1 。<br>
3 Rear: 获取队尾元素。如果队列为空，返回 -1 。<br>
4 enQueue(value): 向循环队列插入一个元素。如果成功插入则返回真。<br>
5 deQueue(): 从循环队列中删除一个元素。如果成功删除则返回真。<br>
6 isEmpty(): 检查循环队列是否为空。<br>
7 isFull(): 检查循环队列是否已满。<br></p> <p>例子 1：</p> <div class="language-js extra-class"><pre class="language-js"><code>MyCircularQueue circularQueue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyCircularQueue</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 设置长度为 3</span>

circularQueue<span class="token punctuation">.</span><span class="token function">enQueue</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 返回 true</span>

circularQueue<span class="token punctuation">.</span><span class="token function">enQueue</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 返回 true</span>

circularQueue<span class="token punctuation">.</span><span class="token function">enQueue</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 返回 true</span>

circularQueue<span class="token punctuation">.</span><span class="token function">enQueue</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 返回 false，队列已满</span>

circularQueue<span class="token punctuation">.</span><span class="token function">Rear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 返回 3</span>

circularQueue<span class="token punctuation">.</span><span class="token function">isFull</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 返回 true</span>

circularQueue<span class="token punctuation">.</span><span class="token function">deQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 返回 true</span>

circularQueue<span class="token punctuation">.</span><span class="token function">enQueue</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 返回 true</span>

circularQueue<span class="token punctuation">.</span><span class="token function">Rear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 返回 4</span>

</code></pre></div><p>注意：</p> <p>所有的值都在 0 至 1000 的范围内；<br>
操作数将在 1 至 1000 的范围内；<br>
请不要使用内置的队列库。<br></p> <h1 id="链表"><a href="#链表" class="header-anchor">#</a> 链表</h1> <h2 id="排序链表"><a href="#排序链表" class="header-anchor">#</a> 排序链表</h2> <p>在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序。</p> <p>例子 1：</p> <div class="language-js extra-class"><pre class="language-js"><code>输入<span class="token operator">:</span> <span class="token number">4</span><span class="token operator">-</span><span class="token operator">&gt;</span><span class="token number">2</span><span class="token operator">-</span><span class="token operator">&gt;</span><span class="token number">1</span><span class="token operator">-</span><span class="token operator">&gt;</span><span class="token number">3</span>
输出<span class="token operator">:</span> <span class="token number">1</span><span class="token operator">-</span><span class="token operator">&gt;</span><span class="token number">2</span><span class="token operator">-</span><span class="token operator">&gt;</span><span class="token number">3</span><span class="token operator">-</span><span class="token operator">&gt;</span><span class="token number">4</span>
</code></pre></div><p>例子 2：</p> <div class="language-js extra-class"><pre class="language-js"><code>输入<span class="token operator">:</span> <span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span><span class="token operator">&gt;</span><span class="token number">5</span><span class="token operator">-</span><span class="token operator">&gt;</span><span class="token number">3</span><span class="token operator">-</span><span class="token operator">&gt;</span><span class="token number">4</span><span class="token operator">-</span><span class="token operator">&gt;</span><span class="token number">0</span>
输出<span class="token operator">:</span> <span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span><span class="token operator">&gt;</span><span class="token number">0</span><span class="token operator">-</span><span class="token operator">&gt;</span><span class="token number">3</span><span class="token operator">-</span><span class="token operator">&gt;</span><span class="token number">4</span><span class="token operator">-</span><span class="token operator">&gt;</span><span class="token number">5</span>
</code></pre></div><p>难点：
需要知道使用哪种排序符合题目的要求，目前符合的只有堆排序</p> <h2 id="跳表"><a href="#跳表" class="header-anchor">#</a> 跳表</h2> <p>升维
空间换时间
利用索引，加大链表遍历的速度</p> <h1 id="矩阵"><a href="#矩阵" class="header-anchor">#</a> 矩阵</h1> <h2 id="螺旋矩阵"><a href="#螺旋矩阵" class="header-anchor">#</a> 螺旋矩阵</h2> <p>给定一个包含 m x n 个元素的矩阵（m 行, n 列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。</p> <p>例子 1：</p> <div class="language-js extra-class"><pre class="language-js"><code>输入<span class="token operator">:</span> <span class="token punctuation">[</span>
  <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token punctuation">]</span><span class="token punctuation">;</span>
输出<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre></div><p>例子 1：</p> <div class="language-js extra-class"><pre class="language-js"><code>输入<span class="token operator">:</span> <span class="token punctuation">[</span>
  <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token punctuation">]</span><span class="token punctuation">;</span>
输出<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre></div><p>难点
1，以大化小，分而治之，复杂的问题可以拆分成比较小的问题，然后利用递归来处理。</p> <h1 id="堆"><a href="#堆" class="header-anchor">#</a> 堆</h1> <p>1，必须是完全二叉树
2，任一节点都是子树的最大值或者最小值</p> <h2 id="超级丑数"><a href="#超级丑数" class="header-anchor">#</a> 超级丑数</h2> <p>编写一段程序来查找第 n 个超级丑数。</p> <p>超级丑数是指其所有质因数都是长度为 k 的质数列表 primes 中的正整数。</p> <p>例子 1：</p> <div class="language-js extra-class"><pre class="language-js"><code>输入<span class="token operator">:</span> n <span class="token operator">=</span> <span class="token number">12</span><span class="token punctuation">,</span> primes <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">13</span><span class="token punctuation">,</span><span class="token number">19</span><span class="token punctuation">]</span>
输出<span class="token operator">:</span> <span class="token number">32</span>
解释<span class="token operator">:</span> 给定长度为 <span class="token number">4</span> 的质数列表 primes <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">13</span><span class="token punctuation">,</span><span class="token number">19</span><span class="token punctuation">]</span>，前 <span class="token number">12</span> 个超级丑数序列为：<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">13</span><span class="token punctuation">,</span><span class="token number">14</span><span class="token punctuation">,</span><span class="token number">16</span><span class="token punctuation">,</span><span class="token number">19</span><span class="token punctuation">,</span><span class="token number">26</span><span class="token punctuation">,</span><span class="token number">28</span><span class="token punctuation">,</span><span class="token number">32</span><span class="token punctuation">]</span> 。

</code></pre></div><p>说明：
1  是任何给定  primes  的超级丑数。
  给定  primes  中的数字以升序排列。
0 &lt; k ≤ 100, 0 &lt; n ≤ 106, 0 &lt; primes[i] &lt; 1000 。
第  n  个超级丑数确保在 32 位有符整数范围内。</p> <h1 id="算法思想"><a href="#算法思想" class="header-anchor">#</a> 算法思想</h1> <h2 id="贪心算法"><a href="#贪心算法" class="header-anchor">#</a> 贪心算法</h2> <h3 id="给定一个数组，它的第-i-个元素是一支给定股票第-i-天的价格。"><a href="#给定一个数组，它的第-i-个元素是一支给定股票第-i-天的价格。" class="header-anchor">#</a> 给定一个数组，它的第  i 个元素是一支给定股票第 i 天的价格。</h3> <p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p> <p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p> <p>例子 1：</p> <div class="language-js extra-class"><pre class="language-js"><code>输入<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span>
输出<span class="token operator">:</span> <span class="token number">7</span>
解释<span class="token operator">:</span> 在第 <span class="token number">2</span> 天（股票价格 <span class="token operator">=</span> <span class="token number">1</span>）的时候买入，在第 <span class="token number">3</span> 天（股票价格 <span class="token operator">=</span> <span class="token number">5</span>）的时候卖出<span class="token punctuation">,</span> 这笔交易所能获得利润 <span class="token operator">=</span> <span class="token number">5</span><span class="token operator">-</span><span class="token number">1</span> <span class="token operator">=</span> <span class="token number">4</span> 。
     随后，在第 <span class="token number">4</span> 天（股票价格 <span class="token operator">=</span> <span class="token number">3</span>）的时候买入，在第 <span class="token number">5</span> 天（股票价格 <span class="token operator">=</span> <span class="token number">6</span>）的时候卖出<span class="token punctuation">,</span> 这笔交易所能获得利润 <span class="token operator">=</span> <span class="token number">6</span><span class="token operator">-</span><span class="token number">3</span> <span class="token operator">=</span> <span class="token number">3</span> 。
</code></pre></div><p>例子 2：</p> <div class="language- extra-class"><pre class="language-text"><code>输入: [1,2,3,4,5]
输出: 4
解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。
     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。
</code></pre></div><p>例子 3：</p> <div class="language-js extra-class"><pre class="language-js"><code>输入<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span>
输出<span class="token operator">:</span> <span class="token number">0</span>
解释<span class="token operator">:</span> 在这种情况下<span class="token punctuation">,</span> 没有交易完成<span class="token punctuation">,</span> 所以最大利润为 <span class="token number">0</span>。
</code></pre></div><h1 id="动态规划"><a href="#动态规划" class="header-anchor">#</a> 动态规划</h1> <h2 id="k-站中转内最便宜的航班"><a href="#k-站中转内最便宜的航班" class="header-anchor">#</a> K 站中转内最便宜的航班</h2> <p>有 n 个城市通过 m 个航班连接。每个航班都从城市 u 开始，以价格 w 抵达 v。</p> <p>现在给定所有的城市和航班，以及出发城市 src 和目的地 dst，你的任务是找到从 src 到 dst 最多经过 k  站中转的最便宜的价格。 如果没有这样的路线，则输出 -1。</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/blog/interview/session.html" class="prev">
        前端安全
      </a></span> <span class="next"><a href="/blog/interview/设计模式.html">
        设计模式
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----></div></div>
    <script src="/blog/assets/js/app.9b8d30b8.js" defer></script><script src="/blog/assets/js/2.0a93f5dd.js" defer></script><script src="/blog/assets/js/12.e0a98157.js" defer></script>
  </body>
</html>
