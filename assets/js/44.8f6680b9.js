(window.webpackJsonp=window.webpackJsonp||[]).push([[44],{392:function(e,t,n){"use strict";n.r(t);var s=n(25),a=Object(s.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h1",{attrs:{id:"react-fiber-中expirationtime-的计算"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#react-fiber-中expirationtime-的计算"}},[e._v("#")]),e._v(" React fiber 中expirationTime 的计算")]),e._v(" "),n("h2",{attrs:{id:"expirationtime"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#expirationtime"}},[e._v("#")]),e._v(" expirationTime "),n("a",{attrs:{id:"expirationtime-&#x516C;&#x5F0F;"}})]),e._v(" "),n("p",[e._v("这里是计算react fiber的过期时间，其实很简单，就是根据当前的操作，计算出来一个过期时间，唯一有点不同的就是这里会根据事件的优先级让在同一时间段内获得的过期时间是一致的，比如低优先级的25ms内，获得的过期时间是一致的，比如"),n("code",[e._v("10002 - 10026")]),e._v("之间，最终得到的结果都是"),n("code",[e._v("10525")]),e._v("，但是到了"),n("code",[e._v("10027")]),e._v("的到的结果就是"),n("code",[e._v("10550")]),e._v("，这就是除以"),n("code",[e._v("25")]),e._v("取整的效果。")]),e._v(" "),n("h2",{attrs:{id:"currenttime"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#currenttime"}},[e._v("#")]),e._v(" currentTime "),n("a",{attrs:{id:"currenttime"}})]),e._v(" "),n("div",{staticClass:"language-javascript extra-class"},[n("pre",{pre:!0,attrs:{class:"language-javascript"}},[n("code",[n("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("function")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[e._v("requestCurrentTime")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  "),n("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// requestCurrentTime is called by the scheduler to compute an expiration")]),e._v("\n  "),n("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// time.")]),e._v("\n  "),n("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// simultaneous 同时")]),e._v("\n  "),n("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// 同一事件触发的更新设置同样的过期时间")]),e._v("\n  "),n("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// Expiration times are computed by adding to the current time (the start")]),e._v("\n  "),n("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// time). However, if two updates are scheduled within the same event, we")]),e._v("\n  "),n("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// should treat their start times as simultaneous, even if the actual clock")]),e._v("\n  "),n("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// time has advanced between the first and second call.")]),e._v("\n  "),n("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// 同一优先级的事件获取同样的过期时间")]),e._v("\n  "),n("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// In other words, because expiration times determine how updates are batched,")]),e._v("\n  "),n("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// we want all updates of like priority that occur within the same event to")]),e._v("\n  "),n("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// receive the same expiration time. Otherwise we get tearing.")]),e._v("\n  "),n("span",{pre:!0,attrs:{class:"token comment"}},[e._v("//")]),e._v("\n  "),n("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// currentRenderTime 用来提高性能，不用每次都去调用performance.now，currentschedulerTime用来记录scheduler 时间")]),e._v("\n  "),n("span",{pre:!0,attrs:{class:"token comment"}},[e._v('// We keep track of two separate times: the current "renderer" time and the')]),e._v("\n  "),n("span",{pre:!0,attrs:{class:"token comment"}},[e._v('// current "scheduler" time. The renderer time can be updated whenever; it')]),e._v("\n  "),n("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// only exists to minimize the calls performance.now.")]),e._v("\n  "),n("span",{pre:!0,attrs:{class:"token comment"}},[e._v("//")]),e._v("\n  "),n("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// But the scheduler time can only be updated if there's no pending work, or")]),e._v("\n  "),n("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// if we know for certain that we're not in the middle of an event.")]),e._v("\n\n  "),n("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// isRendering 不管是在协调阶段还是commit阶段，都会为true， 也就是说在所有的过期时间都是基于同一固定的时间")]),e._v("\n  "),n("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("if")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("isRendering"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n    "),n("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// We're already rendering. Return the most recently read time.")]),e._v("\n    "),n("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// 在render的时候，返回安排的时间")]),e._v("\n    "),n("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("return")]),e._v(" currentSchedulerTime"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n  "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n  "),n("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// Check if there's pending work.")]),e._v("\n  "),n("span",{pre:!0,attrs:{class:"token function"}},[e._v("findHighestPriorityRoot")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n  "),n("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// findHighestPriorityRoot 设置了 nextFlushedExpirationTime = 0")]),e._v("\n  "),n("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("if")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("\n    nextFlushedExpirationTime "),n("span",{pre:!0,attrs:{class:"token operator"}},[e._v("===")]),e._v(" NoWork "),n("span",{pre:!0,attrs:{class:"token operator"}},[e._v("||")]),e._v("\n    nextFlushedExpirationTime "),n("span",{pre:!0,attrs:{class:"token operator"}},[e._v("===")]),e._v(" Never\n  "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n    "),n("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// If there's no pending work, or if the pending work is offscreen, we can")]),e._v("\n    "),n("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// read the current time without risk of tearing.")]),e._v("\n    "),n("span",{pre:!0,attrs:{class:"token function"}},[e._v("recomputeCurrentRendererTime")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n    currentSchedulerTime "),n("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" currentRendererTime"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n    "),n("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("return")]),e._v(" currentSchedulerTime"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n  "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n  "),n("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// There's already pending work. We might be in the middle of a browser")]),e._v("\n  "),n("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// event. If we were to read the current time, it could cause multiple updates")]),e._v("\n  "),n("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// within the same event to receive different expiration times, leading to")]),e._v("\n  "),n("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// tearing. Return the last read time. During the next idle callback, the")]),e._v("\n  "),n("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// time will be updated.")]),e._v("\n  "),n("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("return")]),e._v(" currentSchedulerTime"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n")])])]),n("p",[e._v("如果在rendering阶段，直接返回currentSchedulerTime，如果没有pending work或者其他的直接返回当前的时间，如果有pending work 则直接返回currentScheduleTime。")]),e._v(" "),n("h2",{attrs:{id:"react-fiber-中各种不同的时间含义"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#react-fiber-中各种不同的时间含义"}},[e._v("#")]),e._v(" React fiber 中各种不同的时间含义")]),e._v(" "),n("h3",{attrs:{id:"childexpirationtime"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#childexpirationtime"}},[e._v("#")]),e._v(" childExpirationTime")]),e._v(" "),n("p",[e._v("这个时间是由节点本身产生的，然后不断冒泡到根节点，更新每个父节点上的childExpirationTime")]),e._v(" "),n("h3",{attrs:{id:"earliestpendingtime，lastestpedingtime"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#earliestpendingtime，lastestpedingtime"}},[e._v("#")]),e._v(" earliestPendingTime，lastestPedingTime")]),e._v(" "),n("p",[e._v("这两个很简单，就是在根节点上记录子树的所有最早的过期时间和最晚的过期时间，用来记录一下过期时间的过期时间（过期时间越小，说明优先级越高）")]),e._v(" "),n("h3",{attrs:{id:"earliestsuspendedtime-lastestsuspendedtime"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#earliestsuspendedtime-lastestsuspendedtime"}},[e._v("#")]),e._v(" earliestSuspendedTime, lastestSuspendedTime")]),e._v(" "),n("p",[e._v("Fiber node因为各种原因，需要挂起的最早时间和最晚时间，")]),e._v(" "),n("h4",{attrs:{id:"lastestpingedtime"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#lastestpingedtime"}},[e._v("#")]),e._v(" lastestPingedTime "),n("a",{attrs:{id:"lastestpingedtime"}})])])}),[],!1,null,null,null);t.default=a.exports}}]);